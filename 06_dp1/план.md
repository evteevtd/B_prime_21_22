# Лекция "Динамическое программирование"

## Вступление
- Обычно такие лекции начинают с того, что рассказывают несколько примеров, которые решаются даже без знания того, что такое Динамика, а потом те же задачи рассказывают в немного других тернимах. Давайте рассмотрим пару таких:

#### Префиксные суммы
- Мы знаем, что сумма нуля элементов это 0, так и запишем p[0] = 0;
- Мы знаем, что сумма K элементов, это сумма K-1го и ещё одного, так и зпишем p[K] = p[K - 1] + a[K - 1];
- Если считать их в правильном порядке, а именно сначала p[0], потом p[1] и тд, то есть так, чтобы когда мы считаем Kую, все нужные, чтобы её посчитать уже были посчитаны.

#### Числа Фибаначи
- Числа Фибоначи: F[1] = 1, F[2] = 1, F[k] = F[k - 1] + F[k - 2];
- Для начала распишем наивный вариант - рекурсивная функция, которая всё считает.

		int f(int n) {
			if (n <= 2) return 1;
			return f(n - 1) + f(n - 2);
		}

- Это работает O(F(n)) - можно дерево нарисовать
- Одно и то же число F[i] считает много раз, а зачем? давайте сохранять результаты в res;

		int f(int n) {
			if (n <= 2) return 1;
			if (res[n] == -1) res[n] = f(n - 1) + f(n - 2);
			return res[n];
		}

- так как мы знаем, в каком порядке вычислять F - можно избавиться от рекурсии.

		F[1] = 1, F[2] = 1;
		for (int i = 3; i <= N; i++) {
			F[i] = F[i - 1] + F[i - 2];
		}

## Одна не очень длинная задача (кузнечик)
- представим вот такую ситуацию : в 0й клетке массива стоит кузнечик. Он может прыгать на 1 или на 2 клетки вперед, и хочет допрыгать до клетки номер n, сколькими способами он может это сделать?
- напишем начальные условия: cnt[0] = 1, cnt[1] = 1;
- рассмотрим путь до клетки k - это либо путь до k-1 и прыжек, либо путь до k - 2 и прыжек, итого:
- Напишем рекуренту: cnt[k] = cnt[k - 1] + cnt[k - 2];
- Тогда решение:
	
		cnt[0] = 1, cnt[1] = 1;
		for (int i = 2; i <= k; i++) {
			cnt[i] = cnt[i - 1] + cnt[i - 2];
		}

- теперь пусть можно прыгать на 1, 2, .. , x клеток вперёд, как изменится решение?
- теперь пусть в некоторых клетах яма - такое уже точно не посчитать формулой, но динамикой можно.

#### Полностью другая задача (Андрей, расскажи, как ответ восстановить)
- всё тот же кузнечик хочет добраться от клетки 0 до клетки n, при этом потратив как можно меньше денег
- чтобы наступить на клетку i нужно потратить с[i] денег.

- чтобы добраться до клетки n - нужно опять же сначала попасть в клетки до n, и потом прыгнуть из них - то есть тут напрашивается следующий вариант: dp[i] - минимальная стоимость, за которую можно добраться до клетки i;

- путь от 0 до i-j стоил dp[i-j], а последний прыжек - ещё c[i],тогда
- dp[i] - min по всем j = 1..k dp[i - j] + c[i];

- опять же можно ввести клетки, по которым прыгать нельзя

#### Ещё одна полностью другая задача
- Теперь кузнечик умеет ускоряться и замедляться. Если предыдущий прыжек был на k, то следующий - на k-1, k, k+1. Как дешевле всего добраться до n?;
- dp[i][j] - до клетки i с последним прыжком j

#### Динамика вперёд и назад - разные способы сделать одно и то же

#### Двумерное обобщение - всё то же самое на табличке (задача про черепашку)

---------------------------------------------- Конец лекции Павла Маврина

## Общая идея
- вам нужно что-то посчитать, и вы не знаете как это сделать.
- Для начала стоит задать себе вот такой вопрос: что мне нужно знать, чтобы посчитать ответ за 1 шаг?
- Чтобы посчитать то, что мне нужно, что мне нужно?
- Если на этом шаге вам понадобилось больше, чем у вас уже есть - скорее всего вы обречены, но можно сделать ещё один такой шаг.
- Если всё же вы не нашли конечный набор данных, который мог бы сам себя пересчитывать - либо задача не на динамику, либо вашь первый ответ на "что мне нужно, чтобы посчитать ответ в конце" был не таким, как нужно;

- Разберём всё это вот на каком примере:

### 2 дровосека (написать восстановление ответа)
- 2м дровосекам приходят посылки с едой 3х типов - MFV - мясо фрукты и овощи, а они решают, кто из них будет есть (и, соответственно - работать)
- Если дровосек только что поел, то он смотрит на 3 последних раза, когда он ел, если там 3 различных еды - он рубит 3 дерева, если 2 - 2 дерева, и если 1 - 1 дерево.
- Их задача - к моменту как они всё съедят срубить как можно больше деревьев.

- ну давайте посмотрим, нам нужно понять, сколько максимум они могут срубить, если доели уже всё.
- Чтобы это узнать, давайте посмотрим, сколько они могла срубить, если съели почти всё - n-1 посылку. Дальше последняя отходит либо первому, либо второму, А сколько деревьев он срубит, если съест последнюю?

- достаточно знать, что он съел перед этим, и что ещё до этого (тогда мы будем знать последние 3, а значит - знать, сколько там различных)
- и так, то есть теперь мы хотим хранить n, l1, l2, r1, r2 - сколько посылок съедено, что последним и предпоследним ел дровосек l и дровосек r, умеем ли мы пересчитывать всё это?

- Пусть сейчас состояние n, l1, l2, r1, r2 и дровосек l есть посылку X, тогда мы перейдем в состояние n, l2, X, r1, r2 - ура, новое состояние попадает под шаблон, значит всё можно посчитать. Да - динамика получилась 5ти-мерная, но в этом нет ничего страшного.

## Динамика по подотрезкам

#### Игра
- дана последовательность a1, a2, ... , an, первым ходом я удаляю из неё первый или последний элемент. Потом вы удаляете первый или последний и так далее, пока не останется 1.
- я хочу, чтобы получившийся элемент был как можно больше - вы - как можно меньше, какой элемент на самом деле останется в конце?

- Будем рассуждать так:
	- если в последовательности 1 элемент, то игра окончена
	- если в последовательности k элементов, то на следующем ходу она 1м из 2х способов станет последовательностью из k-1 элемента - либо 1..k-1, либо 2..k

- так и запишем
	- на нечетном ходу dp[l][r] = max(dp[l + 1][r], dp[l][r - 1])
	- на четном ходу dp[l][r] = min(dp[l + 1][r], dp[l][r - 1]);

- мы только что изобрели dp по подотрезкам!
	- в каком порядке нужно перебирать состояния динамики?
	- в порядке увеличения длин отрезков

		for (int i = 0; i < n; i++) {
			dp[i][i] = smth(i);
		}
		for (int len = 2; len <= n; len++) {
			for (int l = 0; l < n - len; l++) {
				int r = l + len - 1;
				dp[l][r] = culc(l, r);
			}
		}

- Если у нас спросили какое-то свойство всего массива - вовсе не факт, что мы сможем посчитать это свойство на префиксе массива - иногда мы просто не сможем придумать переход.

## Ленивая динамика
- На самом деле первая динамика, которую мы написали сегодня - была ленивой (число фибоначи)
- ленивая динамика это способ не думать, в каком порядке пересчитывать состояния.

- хочу ответ в состоянии {n, c, x}, тобы его пересчитать нужны ответы в состояниях {n1, c1, x1}, {n2, c2, x2} и тд.

- Так и напишем
	
		int get(int n, int c, int x) {
			if (dp[n][c][x] == -1) {
				for (int i = 1; i <= k; i++) {
					get(n_i, c_i, x_i);
				}
				dp[n][c][x] = recalc(n, c, x);
			}
			return dp[n][c][x];
		}

- на самом деле это довольно редко бывает полезно
- если вы не понимаете, в каком порядке обходить состояния вашей динамики - скорее всего вы не понимаете, как именно ваша динамика работает
- это скорее спопсоб сократить написание и размышления, пожертвовав временем работы.

## Максимальная подпоследовательность, последователььные элементы которой отличаются не более, чем на 1.

## Восстановление ответа
## Рюкзак
## НВП, НОП





### Ленивая динамика на map (bfs по состояниям)
- Есть 1 случай, когда ленивая динамика может дать преимущество по времени:
- заметим, что по её устройству видно, что она пересчитывает только те состояния, которые на самом деле нужны, чтобы посчитать ответ.
- Представим на секунду, что в нашей задаче огромная часть состояний динамики не достигается, но все эти состояния - нетривиальные, нельзя просто так взять и не хранить их.
- Можно все их обойти ленивой динамикой, а состояния хранить в map

#### Дровосеки
- пусть теперь у дровосеков 4 видов еды и интересуют их 4 последних съеденных.
- можно как и раньше, завести динамику на n * 4^8 состояний и пересчитывать. Но более или менее очевидно, что на самом деле далеко не все комбинации из этих 4^8 достижимы, есть даже ощущение, что возможных - заметно меньше, чем невозможных

- сделаем вот что - map < vector < int>, int> - ответ для состояния {ind + 4 последних еды 1ого дровосека + 4 последних еды второго}
	
		map < vector < int>, int> MEM;
		dp[{0, -1, .. -1}] = 1;
		queue < vector < int > > bfs;
		bfs.push_back({0, -1, .. -1});
		while (!bfs.empty()) {
			vector<int> state = bfs.front();
			bfs.pop();
			if (state[0] == n) {
				ans = max(ans, MEM[state]);
				continue;
			}
			for (по всем state1, достижимым из state) {
				if (!MEM.count(state1)) {
					bfs.push(state1);
				}
				MEM[state1] = max(MEM[state1], MEM[state] + add(state, state1));
			}
		}
		cout << ans << '\n';



