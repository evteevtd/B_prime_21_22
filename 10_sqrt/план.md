# Корневая

## Немного поболтаем.

- есть задачи, в которых написать частичное решение фактически невозможно. Всякие задачи на ДП или какие-то жадники. То есть те задачи, в которых 
	- наивное решение экспоненциально долгое
	- основная сложность - придумать как вообще можно решить задачу, а о времени работы думать во вторую очередь.

- Но есть другой тип задач - задачи на оптимизацию времени работы решения, и они всречаются не менее часто.
- простой пример: задача следующего вида: дан массив и приходят запросы вида "прибавить на отрезке" и "вычислить сумму на отрезке". И многие из вас наверняка знают разные быстрые способы это решать, но сейчас не об этом.
-Если бы я попросил вас написать программу, которая работает не катастрофически медленно и выполняет этот запрос - вы бы спраились за пол минуты, потому что в условии буквально сказанно, что я от вас хочу - пройтись по отрезку и добавить что-то к каждому числу, и пройтись по отрезку и найти сумму - что может быть проще?.
- сегодня мы будет учиться писать более быстрые алгоритмы для решения очень простых задач.

## Классическое "разобьем на блоки по корню"

- очевидно, с чего стоит начать:
	- \+ на отрезке
	- sum на отрезке
- идея с отложенными операциями

- что ещё можно сделать?
	- всякие очевидные пары вида
		- \+ на отрезке min на отрезке
		- min= на отрезке, min на отрезке
		- and= на отрезке, xor на отрезке
		- присвоить на отрезке -//- на отрезке
- как понять, можно ли сделать те или иные операции на отрезке с помощью корневой?
	- тут есть тонкости, то, что я расскажу, не будет необходимым условием, а так же не всегда будет достаточным. ко многим из задачь, которые я обозначу есть замысловатые обходные пути, но здесь речь именно о классическом варианте без заморочек.
- 1 ) нужно уметь комбинировать 2 операции в одну:
	- что такое +=a, затем +=b? - это то же, что += (a + b);
	- что такое min= a, затем min= b? - ...
	- что такое +=a, затем = b? а в обратном порядке?
	- что такое %= a, затем %= b? - ... просто так не выйдет - плохой знак, видимо без доп заморочек не получится.
- 2 ) нужно понимать, как изменение нескольких элементов влияет на ответ в целом. (то есть уметь применять push без проталкивания). Например:
	- если на отрезке максимум был = x, а потом ко всему отрезку применили min=y, каков максимум на отрезке теперь?
	- если на отрезке сумма была x, а потом ко всем элементам применили min=y, какая сумма теперь? (не получится)

- операции не ограничиваются простыми арифмитическими - идея "а давайте разобьем на блоки по корню" - может помочь в совершенно неожиданном месте.

## Откуда вообще может вылезти корень?

- помните было такое, что сумма 1+2+3+...+n = n(n + 1) / 2?
- так вот представьте, что вам дали сколько-то чисел, таких что их сумма =N, сколько среди них различных?
- довольно очевидно, что их порядка sqrt(n), 1 способ думать об этом - в терминах "худшего случая" - он очевидно 1+2+3+...+k = n, то есть k = sqrt(2 * n);
- другой способ дает более грубую оценку, но в общем случае более полезен:
	- чисел не больше sqrt(n) - всего sqrt(n);
	- чисел больше sqrt(n) - не может быть больше sqrt(n), так как иначе бы сумма была больше n.
	- оценка: 2\*sqrt(n);
- то есть ели вам дают, например, сколько-то строк, суммарной длины n, вы знаете, что среди них не больше чем 2\*sqrt(n) различных длин. - это бывает полезно.

## Корневая на графах.

- люди, которые знают, что такое Дерево Отрезков часто недооценивают мощь корневой декомпозиции, потому что их уровень её восприятия остановился на уровне "+ на отрезке /сумма на отрезке". но на самом деле она может гораздо больше:
- дан граф, в котором каждая вершина покрашена в тот или иной цвет. Поступают запросы "поменять цвет вершины". Посе каждого такого нужно сказать, сколько ребер в графе соединяют вершины одинаковых цветов.

### Рассказать черно-белую версию.

### Идея:

- разобьем вершины на "легкие" и "тяжелые". Легкие - те, у которых не больше C ребер, тяжелые - у кого больше. С подберём потом.
- Чем обусловлено такое разбиение?
	- вершины с большим кол-вом ребер как бы "важные". К ним нужен индивидуальный подход, их не получится обработать "по-простому".
	- для вершин с маленьким кол-вом ребер можно поступить очень просто: как только у какой-то меняется цвет, ана бежит ко всем своим соседям, благо их немного, и просто "сообщает" им об этом. Она может себе это позволить.

### Детали:

- пойдем от простого к сложному
- первым делом насчитаем ответ, а дальше научимся его поддерживать.

#### Л -> Л
- пусть цвет поменялся у легкой вершины, и пока пробегали по её соседям мы наткнулись на ещё одну легкую вершину, что делать?
	- ничего!
	- если они были одного цвета, а стали разного, то вычтем 1, если были разного, а стали одного - прибавим, и больше ничего.

#### Л -> Т
- пусть цвет поменялся у легкой вершины, и пока она обходила соседей, она наткнулась на тяжелую.
- по началу кажется, что можно опять же просто прибавить или вычесть 1, давайте пока так и сделаем, а потом будем разгребать последствия

#### Тревога! Т поменяла цвет
- тяжелая вершина поменяла цвет, и нам нужно оперативно на это среагировать. Пройтись по всем её соседям мы не успеем, так что нам придется сохранить в тяжелой вершине полный список её соседей и их цветов. Давайте сделаем это в map<цвет, кол-во>
- теперь когда тяжетая вершина меняет цвет достаточно вычесть сколько в мапе лежит по прошлому цвету, и добавить - сколько по новому.

#### Инвариант
- чтобы не запутаться, нам нужна всегда соблюдать своего рода правила - установить границы допустимого и не выходить за них. В данном случае, мы обещаем себе, что в конце каждого изменения каждая тяжелая вершина будет хранить корректную мапу своих соседей, попробуем этого добиться.

- когда легкая вершина пробегает  по своим соседям, если они оказались тяжелыми - нужно поменять значение в их мапе.
- если у тяжелой вершины поменялся цвет, то ТОЖЕ нужно пробежаться по всем её тяжелым соседям (их тоже немного) и поменять им всем мапу.
- (для этого удобно после считывания посортить все списки смежности с соответсвующим компоратором).

### Треугольники
- есть одна древняя задача: посчитать, сколько в графе циклов длины 3 (ака треугольников), и у неё есть стандартное решение, а есть хитрое, какое писать - решайте сами.

- стандартное - это разбить все вершины на легкие и тяжелые, а дальше отдельно рассмотреть все "виды" треугольников - ТТТ, ТТЛ, ТЛЛ, ЛЛЛ. Давайте попробуем это сделать:
- если треугольник ЛЛХ - обозначим за a и b легкие вершины в нем. Теперь пройдемся по их спискам смежности и найдем общие вершины - всего мы это сделаем за m\*sqrt(m).
- если треугольник TTX - зафиксируем пару TX - способов сделать это не больше m, а к ним в тройку добавим 3ю вершину T (за sqrt(m))
- возможно удобнее будет рассматривать все 4 случая отдельно, чтобы не запутаться, сколько раз что нужно посчитать.
- чтобы за О(1) проверять наличие ребра между вершинами можно завести unordered_map пар, но этого может быть недостаточно. Воспользуемся следующим трюком. Мы в начале фиксируем первую вершину, а когда зафиксировани - пройдем по всем её соседям и поставим used в соответствующей ячейке. так как нам наличие ребра пирдется проверять только с этой вершиной, мы сможем делать это за О(1).
- В качестве бонуса - можно сделать всё это в 1 цикле, просто посортив вершины по убыванию массы, и идя в следующую, только если она большего номера.

## Корневая по запросам.
- это очень мощьный инструмент, который позволяет  упростить себе жизнь в 1000 раз, когда авторское решение, это что-то сложное, мерзкое и долгое за какие-нибудь nlog^2, а вы можете написать корневую по запросам, это будет (n + q)sqrt(q), и работать будет быстрее авторского. 

### Основная идея:
- мы ленивые, так что давайте откладывать кучу дел, которую нам нужно сделать так долго, как только можно:
- нам приходят запросы изменения, но мы просто складываем их в кучу с неотвеченными запросами, когда нас о чем-то спрашивают, мы освечаем с учетом этих изменений, а когда их скапливается слишком много - перестраиваем всё с нуля.

### Ikea на минималках.
- выпуклая область клеток, запросы вида "построить болььницу в клетке i j", и "ближайшая больница к клетке i j".
- будем в мешок складывать больницы, которые нужно построить, но мы ещё не, а так же для каждой клетки - ближайшую из уже построенных больниц. Когда приходит запрос ближайшей, мы берём уже насчитанный ответ, а затем пробегаемся по всем больницам в мешке, и обновляем ответ через них. Когда их скапливается много - запускаем из них BFS, пересчитывая расстояние до всех клеток.

## Великий и ужасный алгоритм MO
- минимум на отрезке за n\*sqrtn\*logn
- минимум на отрезке за n\*sqrtn
- кый-минимум на отрезке за n\*sqrtn

### Наивный алгоритм.
- у нас уже была задача минимум на окне, тавайте её слегка обобщим:
- дан массив и q запросов l_i, r_i, при чем известно, что l_i <= l_{i+1} и r_i <= r_{i+1}. найдите минимум на каждом из этих отрезков.
- в версии 0iq мы заводили мультисет и как бы между запросами двигали границы, что нам мешает сделать то же самое?
- поставим 2 указателя в клетки l и r, такие, что мы знаем минимум на отрезке l, r. например 0 и 0. Нашь первый запрос - l_0, r_0 - "дойдем до него" - то есть сдвинем правую границу по шажочку, а потом левую. на каждом шаге нужно как-то уметь находить минимум - для этого заведем мультисет из элементов на отрезке [l .. r). Когда двигаем границы, просто убираем или добавляем нужный элемент. Чтобы нечаянно не сделать отрезок отрицательной длины, сначала будем двигать <-l, потом r->, l->, <-r.
- это вполне себе корректный алгоритм, правда работает он за n^2logn. - это не круто. Все дело в том, что наши запросы как-то раскиданы в разные стороны, их ры переупорядочить, и всё будет круто.

### Правильный порядок

- таким упорядочиванием служит следующая идея: давайте те запросы, у которыч левые границы "рядом" положим вместе. а именно - отсортируем запросы по floor(l/C). а в этой кучке, отсортируем по r. Посчитаем, что получится.
- когда мы внутри одного блока - правая граница едет только вперед, то есть всего n действий, а левая - ходит туда-сюда в пределах С шагов, то есть всего q\*C шагов левой границы и n/C * n шагов правой.
- если n = q, а C = sqrt(n), то получаем 2nsqrt(n) шагов, каждый за лог.

### Избавляемся от log 2мя способами.
- 1 ) вместо того, чтобы одним куском держать весь отрезок l..r, отдельпо рассмотрим от разделителя до r, и от разделителя до l. Так вот второе можно каждый раз заново считать за sqrt, а правый двигается только вперед, можно просто поддерживать 1 число - min.

- 2 ) Мы всё это время использовали multiset, - эта структура умеет добавлять и удалять элементы за log, а так же находить минимум за log. В результате мы nsqrtn раз добавили элемент, а потом q раз спросили минимум, итого nsqrtnlogn + qlogn, а можно ли лучше? - да, можно сделать "set", который добавляем и удаляем числа за 1, а узнает минимум за sqrt.

### К-ый максимум на отрезке.
- вроде бы эту задачу можно как-то решить за qlog^2n с огромной константой. Но можно немного похитрить и написать алгорист МО с той же идеей "сета", с добавлением за 1, и "кый максимум" за sqrt.




