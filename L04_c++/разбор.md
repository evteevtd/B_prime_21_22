# Разбор

## Сортировки

#### L - Число
- дано n строк с чилами, возможны лидирующие 0, какое максимальное число можно получить их склейкой?

###### Что нужно было сделать?
- напишем компоратор, который проверяет, какое число больше, ab или ba.
- думать не нужно было, нужно было засылать!
	- кто-нибудь из тех кто сдал умеет доказывать?

###### А теперь немного таки подумаем
- Пусть у двух чисел отличается первая цифра, тогда то, у которого она больше, будет стоять раньше
- Пусть у двух чисел совпадает префикс длины l, но после него у обоих есть цифра
	- то, у которого цифра больше в ответе стоит раньше
- Пусть одно чило - префикс другого (интересный случай)
	- строка l префикс строка m. Выкинем из строки m первые |l| символов и сравним l и m, какая больше, та вперёд. Почему?
	- Если в ответе меньшая стоит перед большей, то посмотрим на строку после неё. А теперь свопним l и m местами. То, что получилось - больше. (Нужен рисунок, просто так это не очевидно)

###### напутствие
- такая идея - не думать, какой компоратор, а проверить, что локально лучше, ab или ba - встречается очень часто.





## Бинпоиск

#### A - поиск позиции
- дано 2 массива a[N] и x[M]. Для каждого x[i] найти позицию p, такую что 
	- #(j: j < p, a[j] == x[i]) * #(j: j >= p, a[j] != x[i]) максимально.

###### Очень хочется бинарить, но нельзя!
- В тестовых случаях уже видно, что в функции бывают равные значения подряд. На самом деле она к тому же может уменьшаться и увеличиваться, как ей угодно (почти на любом тесте, кроме тех, что в условии) - так что тернарный поиск тут просто не годится, нужно думать шире!

###### Решение
- Заметим, что число X выгодно поставеть сразу справа от какого-то вхождения X в массив
- Заведём vector < vector < int > > - для каждого значения X (до 1e5) будем хранить позиции его вхождения
- суммарный размер такого вектора - O(n + C);
- Решим задачу для конкретного X. Пройдемся по всем его вхождениям, посчитаем max(i * (n - pos[i])).
- Осталось посчитать и сохранить ответ для всех чисел от 1 до 10^5 - дальше только выводить их;


#### H - when democracy fails
- Есть 2 массива b[N] и r[i] - нужно выбрать индекс i, такой что b[i] + (сколько избирателей нужно подкупить) - минимально.

###### O(nlog^2 / nlog + C)
- отсортируем партии по убыванию r[i] и нарисуем гистограмму.
- Давайте для конкретной партии попробуем посчитать, сколько человек нужно подкупить, чтобы она победила.
	- людей нужно подкупать только из партий левее (или если 2 партии топ 1, то ответ 1)
	- давайте забинарим, сколько голосов нужно добавить этой партии. Пусть мы проверяем M.
		- возьмем все партии с кол-вом голосов >= r[i] + M, пусть на гистограмме выше этого уровня Y клеток. Если r[i] + Y > M, то ответ больше M, иначе не меньше M.
	- как найти кол-во клеток в гистограмме, выше уровня H?
	- (log)
		- Насчитаем префиксные суммы r[i].
		- Забинарим первую позицию гистограммы, в которой r[i] < Y.
		- Ответ Pref[pos] - pos * Y;
	- O(1)
		- Заведем массив add[10^6].
		Прибавим add[r[i]] += 1 для всех i.
		Насчитаем префиксные суммы сверху вниз.
		- Pref[Y] = число клеток выше позиции Y в гистограмме

###### Математика O(n);
- Если немного посидеть с математикой, то можно пересчитывать ответ из ответа для предыдущего человечка, но это очень неприятно, зато работает за O(n);


#### J - точки на плоскости
- я не хочу разбирать эту задачу. Её подробный разбор был на лекции в разделе вложенные бинпоиски

#### K - минимизируем максимум
- Дано много убывающих и много возрастающих массивов.
- Для некоторох пар из них найти min_i(max(a[i], b[i]));

###### Тернарник? - нет
- заметим, что функция сначала убывает, а потом возрастает. Ура?
	- нет, она иногда стоит на месте, а значит тернарить нельзя. Что же делать?
- замеим, что так как a возрастает, а b убывает, то если a[i] < b[i], то ответ не левее i и аналогично в другую сторону. (нарисовать на доске 2 кривых в разные стороны)
- можно бинарить по этому признаку

#### L - вырубка леса
- нужно найти наименьшее Y, такое что A * (Y - Y / K) + B * (Y - Y / M) >= X;

###### Борьба с переполнением - 3 стула
- Вместо того, чтобы думать, в каких границах бинарить, для поиска R запустим галлопинг.
- Немного подумаем, и определим R = 2 * X / (a + b) + 100, если m, k != 1, иначе 4 * X / (a + b) + 100;
- Если A * (Y - Y / K) > X, то F(Y) уж точно >= X.
	- Проверим, что (Y - Y / K) <= X / A и (X - X / M) <= X / B. Если нет, то всё очев, иначе проверяем по честному. 

#### M - осколки прошлого
- Есть интерактивные комнаты, расположенные по кругу, можно ходить и включать / выключать свет. Нужно за <= 10 * ans операций найти кол-во комнат.

###### Идея
- Пусть нам нужно сделать не <= 10 * ans операций, а <= 10 * N, (где N - максимальное число комнат = 2000)
- Для начала N раз сходим направо, запоминая последовательность из 0 и 1 - свет в комнатах. 
- Переключим свет в комнате
- N раз сходим налево, сверяя строку из 0 и 1. Если где-то несовпадение, то мы нашли период.
	- (нарисовать рисунок)

###### Решение
- Пусть 1 <= ans < 2. Тогда в нашем распоряжении хотя бы 10 запросов. Сходим 1 раз направо, переключим свет, сходим налево. Если свет что и раньше, значит мы потратили 3 операции, и узнали, что ans >= 2;
- Пусть 2 <= ans < 4. Тогда у нас хотя бы 20 запросов, 3 из которых мы уже потратили. Сходим на право 3 раза, переключим свет и сходим 3 раза налево. Если всё как раньше, то ответ >= 4 и мы потратили ещё 7 запросов.
- Пусть 4 <= ans < 8. - 7 вправо + 1 + 7 влево и так далее.
- Сколько запросов мы так сделаем?
	- 3 + 7 + 15 + 31 + ... + (2^(k + 1) - 1 : 2^(k - 1) < ans)
	- операций < 2^(k + 2) = 8 * 2^(k - 1);
	- 2^(k - 1) < ans => 2^(k + 2) < 8 * ans. А этого нам хватает.


#### N - Oracle соло мид
- a - урон. b - восстановление в секунду, c - сколько времени восстановление, d - время перзарядки
- будем считать, что мы не наносим урон, а наоборот что-то добавляем. Тогда вопрос, сколько максимум можно добавить.

###### Решение
- если a > b * c - то можно добавить сколько угодно. Ответ -1
- если d > c, то к следующему применению всё точно упадет ниже 0 -> Ответ a
- теперь нам нужно применить способность от 1 до c / d раз. Больше точно не нужно, так как к последняя атака должна быть до того, как закончится побочный эффект первой.
- Научимся считать, какое что получится, если мы применим способность M раз, а дальше Тернарник.
	- = a\*M - (d \* ((M-1) \* M) / 2) \* b;

###### Математика
- можно решить задачу аналитически - опять же посидеть с листочком и вычислить оптимальное кол-во атак. Это не очень сложно, но кажется думать таки придется больше.






## Графы - DFS

#### B - Отбой
- текущая задача : выжить
- Если мы пройдем через дом Дениса Павловича, то мы не сможем добраться больше ни до какого дома, потому что если из нашей вершины ведёт <= m / 2 ребер, то их все можно перекрыть, иначе не по всем нин достижима итоговая вершина (рисунок).
- -> исключим дом Дениса Павловича из графа - задача превратилась в следующее:
- для нескольких пар вершин в графе проверить, верно ли, что одна достижима из другой
- так как граф неориентированный, это эквивалентно проверке того, что они в одной компоненте связности.

#### C - Авиаперелёты
- какого размера бак нужен, чтобы из любой вершины ориентированного графа можно было долететь до любой другой?
- так как можно дозаправляться в каждой вершине - мы можем беспрепятственно перемещаться по ребрам веса не больше размера бака, и не можем по остальным.
- Если рассматривать полный граф, и убирать из него ребра в порядке уменьшения веса, то первое время из каждой вершины будет достижима каждая, а с какого-то момента это прекратится 
- можно найти границу бинпоиском.
	- для некоторого W построим граф на ребрах веса не больше W, потом запустим dfs из каждой вершины, и проверим, что все вершины попарно достижимы.
- решение за n * n * log(C);

#### D - Автостопом по планетам
- дано 2 ориентированных графа, проверить, что нет пары вершин a, b таких что b достижима из a в обоих графах.
- так как вершин немного, можно просто для каждой вершины a выписать все вершины, достижимые из неё в одном графе, и все, достижимые в другом, и проверить, нет ли пересечений.

#### E - The One with the Cop (диван)
- Какой максимальный диван можно дотащить из левой половины (в начале параллельно) до правой половины (в конце параллельно), если можно его поворачивать вокруг края и двигать параллельно длине.

###### Сведение
- Если диван длины l дотащить можно, то можно и диван длины x - 1, а значит диваны до какой0то длины дотащить можно, а после неё - нельзя, найдем границу бинпоиском.
- -> можно ли по установленным правилам дотащить диван длины M?
- Почти любая задача формата "можно ли из одного состояния перебраться в другоё делая маленькие шажки" решается графами. Остаётся разве что понять, что в графе вершины, а что ребра.

###### Вершины
- Так как диван можно поворачивать только держа за угл, можно считать, что его и держать можно только за угол, а значит положение дивана однозначно кодируется 3мя числами (x, y, r) - кооодинаты и r отвечающее за поворот (пусть 0 - вверх, а дальше по часовой стрелке). (+рисунок)
- Вершинами нашего графа будут тройки чисел (x, y, r). Всего их n * m * 4;

###### Ребра
- Что является ребрами - неявно сказано в уловии:
	- Диван можно перемещать на +-1 вдоль направления r
	- Диван можно поворачивать вокруг точки (x, y);
	- Можно поменять край, за который ты держишь диван, то есть сменить (x, y) на позицию противоположного края и сменить r на противоположный.

###### Препятствия
- Если мы хотим переместить диван в корректное (с точки зрения переходов (x, y, r)) положение, нам могут помешать препятствия, однако это можно проверить за M операций. Так же нужно не забыть проверить, что после преобразования диван не вылез за границы поля.
	- все эти проверки стоит вынести в bool check(int x, int y, int r);

###### Итог
- Найдем в столбце слева все позиции (x, y, r) в которых диван может стартовать.
- Не будем строить граф явно, вместо этого будем перемещаться между тройками чисел (x, y, r) по описаным выше правилам и помечать посещенные в массиве int used[N][N][4];
- запустим dfs по очереди из всех корректных вершин слева, не обнуляя used, и посмотрим, достижима ли из них хоть одна вершина (n - 1, y, 0) - нужная вершина справа. Если да, то для данной длины ответ Да, иначе нет.
- Итоговая асимптотика N * N * N * log(N) - должно заходить.

#### I - Свинки копилки
- ключ от каждой копилки в какой-то другой копилке. Сколько минимум нужно разбить, чтобы открыть все?






































