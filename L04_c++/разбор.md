# Разбор

## Сортировки

#### L - Число
- дано n строк с чилами, возможны лидирующие 0, какое максимальное число можно получить их склейкой?

###### Что нужно было сделать?
- напишем компоратор, который проверяет, какое число больше, ab или ba.
- думать не нужно было, нужно было засылать!
	- кто-нибудь из тех кто сдал умеет доказывать?

###### А теперь немного таки подумаем
- Пусть у двух чисел отличается первая цифра, тогда то, у которого она больше, будет стоять раньше
- Пусть у двух чисел совпадает префикс длины l, но после него у обоих есть цифра
	- то, у которого цифра больше в ответе стоит раньше
- Пусть одно чило - префикс другого (интересный случай)
	- строка l префикс строка m. Выкинем из строки m первые |l| символов и сравним l и m, какая больше, та вперёд. Почему?
	- Если в ответе меньшая стоит перед большей, то посмотрим на строку после неё. А теперь свопним l и m местами. То, что получилось - больше. (Нужен рисунок, просто так это не очевидно)

###### напутствие
- такая идея - не думать, какой компоратор, а проверить, что локально лучше, ab или ba - встречается очень часто.


## Бинпоиск

#### A - поиск позиции
- дано 2 массива a[N] и x[M]. Для каждого x[i] найти позицию p, такую что 
	- #(j: j < p, a[j] == x[i]) * #(j: j >= p, a[j] != x[i]) максимально.

###### Очень хочется бинарить, но нельзя!
- В тестовых случаях уже видно, что в функции бывают равные значения подряд. На самом деле она к тому же может уменьшаться и увеличиваться, как ей угодно (почти на любом тесте, кроме тех, что в условии) - так что тернарный поиск тут просто не годится, нужно думать шире!

###### Решение
- Заметим, что число X выгодно поставеть сразу справа от какого-то вхождения X в массив
- Заведём vector < vector < int > > - для каждого значения X (до 1e5) будем хранить позиции его вхождения
- суммарный размер такого вектора - O(n + C);
- Решим задачу для конкретного X. Пройдемся по всем его вхождениям, посчитаем max(i * (n - pos[i])).
- Осталось посчитать и сохранить ответ для всех чисел от 1 до 10^5 - дальше только выводить их;


#### H - when democracy fails
- Есть 2 массива b[N] и r[i] - нужно выбрать индекс i, такой что b[i] + (сколько избирателей нужно подкупить) - минимально.

###### O(nlog^2 / nlog + C)
- отсортируем партии по убыванию r[i] и нарисуем гистограмму.
- Давайте для конкретной партии попробуем посчитать, сколько человек нужно подкупить, чтобы она победила.
	- людей нужно подкупать только из партий левее (или если 2 партии топ 1, то ответ 1)
	- давайте забинарим, сколько голосов нужно добавить этой партии. Пусть мы проверяем M.
		- возьмем все партии с кол-вом голосов >= r[i] + M, пусть на гистограмме выше этого уровня Y клеток. Если r[i] + Y > M, то ответ больше M, иначе не меньше M.
	- как найти кол-во клеток в гистограмме, выше уровня H?
	- (log)
		- Насчитаем префиксные суммы r[i].
		- Забинарим первую позицию гистограммы, в которой r[i] < Y.
		- Ответ Pref[pos] - pos * Y;
	- O(1)
		- Заведем массив add[10^6].
		Прибавим add[r[i]] += 1 для всех i.
		Насчитаем префиксные суммы сверху вниз.
		- Pref[Y] = число клеток выше позиции Y в гистограмме

###### Математика O(n);
- Если немного посидеть с математикой, то можно пересчитывать ответ из ответа для предыдущего человечка, но это очень неприятно, зато работает за O(n);


#### J - точки на плоскости
- я не хочу разбирать эту задачу. Её подробный разбор был на лекции в разделе вложенные бинпоиски

#### K - минимизируем максимум
- Дано много убывающих и много возрастающих массивов.
- Для некоторох пар из них найти min_i(max(a[i], b[i]));

###### Тернарник? - нет
- заметим, что функция сначала убывает, а потом возрастает. Ура?
	- нет, она иногда стоит на месте, а значит тернарить нельзя. Что же делать?
- замеим, что так как a возрастает, а b убывает, то если a[i] < b[i], то ответ не левее i и аналогично в другую сторону. (нарисовать на доске 2 кривых в разные стороны)
- можно бинарить по этому признаку

#### L - вырубка леса
- нужно найти наименьшее Y, такое что A * (Y - Y / K) + B * (Y - Y / M) >= X;

###### Борьба с переполнением - 3 стула
- Вместо того, чтобы думать, в каких границах бинарить, для поиска R запустим галлопинг.
- Немного подумаем, и определим R = 2 * X / (a + b) + 100, если m, k != 1, иначе 4 * X / (a + b) + 100;
- Если A * (Y - Y / K) > X, то F(Y) уж точно >= X.
	- Проверим, что (Y - Y / K) <= X / A и (X - X / M) <= X / B. Если нет, то всё очев, иначе проверяем по честному. 

#### M - осколки прошлого
- Есть интерактивные комнаты, расположенные по кругу, можно ходить и включать / выключать свет. Нужно за <= 10 * ans операций найти кол-во комнат.

###### Идея
- Пусть нам нужно сделать не <= 10 * ans операций, а <= 10 * N, (где N - максимальное число комнат = 2000)
- Для начала N раз сходим направо, запоминая последовательность из 0 и 1 - свет в комнатах. 
- Переключим свет в комнате
- N раз сходим налево, сверяя строку из 0 и 1. Если где-то несовпадение, то мы нашли период.
	- (нарисовать рисунок)

###### Решение
- Пусть 1 <= ans < 2. Тогда в нашем распоряжении хотя бы 10 запросов. Сходим 1 раз направо, переключим свет, сходим налево. Если свет что и раньше, значит мы потратили 3 операции, и узнали, что ans >= 2;
- Пусть 2 <= ans < 4. Тогда у нас хотя бы 20 запросов, 3 из которых мы уже потратили. Сходим на право 3 раза, переключим свет и сходим 3 раза налево. Если всё как раньше, то ответ >= 4 и мы потратили ещё 7 запросов.
- Пусть 4 <= ans < 8. - 7 вправо + 1 + 7 влево и так далее.
- Сколько запросов мы так сделаем?
	- 3 + 7 + 15 + 31 + ... + (2^(k + 1) - 1 : 2^(k - 1) < ans)
	- операций < 2^(k + 2) = 8 * 2^(k - 1);
	- 2^(k - 1) < ans => 2^(k + 2) < 8 * ans. А этого нам хватает.

#### N - Oracle соло мид
- 



























