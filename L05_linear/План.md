# План лекции "Линейные алгоритмы"

## Стек
### Что такое стек
- одна из самых простых структур, котоые только можно придумать:
	- стек умеет добавлять элемент в конец, смотреть какой элемент в конце, удалять элемент с конца.
	- о том, как расширить его возможности поговорим позже.
- Как это устроено:
	- заведём структру, которая будет хранить нужный нам элемент и ссылку на другую такую же структуру
		

			struct node {
				int value;
				node* par;
				...
			};

- - Теперь соберём для этого оболочку:


		struct stack {
			node* root;
			void push(int key) {}
			void pop() {}
			int top() {}
			...
		};
- Можно заметить, что vector умеет то же самое, и гараздо больше.
- Но чтобы достич функционала stack нам хватило попросить от языка очень немногое:
	- уметь выделять немного памяти и говорить, где он её выделил. Вектор требует гораздо больше.

- мы ещё верёмся к структурам, связанным со стекам, но пока поговорим о его применениях

### Учимся решать задачи на стек

#### Ближайший меньший слева
- дан массив a, для каждого a[i] найти ближайший элемент слева (max j < i), такой что a[j] < a[i]

##### n^2
- пойдем по индексам i, и для каждого пойдем влево, пока не найдем интересующий нас элемент.

##### Идея и решение
- пусть где-то в массиве есть маленький элемент a[i]. И пусть для некоторого j > i мы сейчас идем справа на лево в поисках подходящего элемента, и сейчас смотрим на iый.
	- если a[i] < a[j], то всё отлично, мы нашли, что искали, иначе:
	- мы уже знаем, что кучка эл-тов слева от i больше, чем a[i], а значит и больше, чем a[j]. Тогда зачем нам их рассматривать, ответ точно не в них, давайте сразу прыгнем в ближайший слева меньше a[i].
- Перед тем, как поговорить, почему это работает быстро, давайте представим себе это по-другому:
	- давайте сохраним стек индексов (так называемый слек минимумов) - обладающий вот каким свойством:
	- если где-то в стеке лежит позиция i, то перед ней в стеке лежит позиция длижайшего меньшего слева от i элемента.
	- теперь идем слева направо и пытаемся поддерживать этот стек:
		- мы стоим в элементе i, и нам очень хотелось бы добавить элемент i в стек, но просто так это сделать нельзя. Перед этим, пока в стеке лежат элементы >= a[i] будем их удалять.
		- теперь в конце стека лежит ответ для индекса i, запишем его.
		- а вот теперь добавим индекс i в стек.
	- Сколько это работает:
		- если пытаться рассуждать совсем наивно, то у нас есть какой-то стек, и за один раз мы можем удалить из него хоть n элементов, так всего n раз, а значит точно не больше O(n^2), но это слишком грубая оценка.
		- Давайте вот что сделаем: Перед тем, как положить элемент в стек дадим ему 2 монеты, этими монетами он в будущем сможет платить за операции, которые мы с ним совершаем, и так:
		- Когда мы дошли до индекса i, мы первым делом смотрим в стек, Если элемент в конце стека > a[i], то он 1 монетой оплатит то, что мы на него посмотрели, и ещё одной - то, что мы его удалили, итого - такая операция оказалась для нас бесплатна.
		- если же элемент в стеке < a[i], то сами заплатим 1 монету за то, что посмотрели на этот эл-т, 1 на то, чтобы элемент i положить в стек и ещё 2 монеты дадим ему с собой.
		- Итого: Мы прошлись по всем элементам и на обработку каждого потратили 4 монеты, то есть суммарне время работы 4\*n (+ ещё записать ответ O(n)) = O(n) - а о лучшем и мечтать нельзя

##### Замечание
- такая идея - проход со стеком и поддержание чего-то интересного на нем используется очень много где, и мы обязательно ещё с этим столкнёмся.
- писать этот алгорим на стеке совсем не обязательно, мы уже говорили, то у нас есть vector, который может всё то же самое, при чем за то же время, так что конечно же можно писать на vector, пользуюсь им, как стеком.

### Гистограмма
- дан массив a[N] - высоты столбцев гистограммы, найти максимальный прямоугольник, который можно в неё вписать
- У максимального прямоугольника всяко есть столбик, который по высоте равен высоте прямоугольника, переберём этот самый столбик, и для него жадно найдем подходящий прямоугольник:
	- Если i - минимальный столбик в прямоугольнике, то сам прямоугольник - от первого слева меньше iого, до первого справа меньше iого. - а это мы насчитали за O(n) - для каждого i можно найти соответствующий ему прямоугольник за O(1);


## Трюки с префиксными суммами

### Сначала без трюков: просто префиксные суммы
- пусть у нас есть массив int a[N] длины N, чтобы не запутаться будем использовать 0-индексацию, то есть элемены массива - a[0], a[1] ... a[n - 1];
- заведём массив p (префиксных сумм) - p[i] = a[0] + a[1] + ... + a[i - 1]; Длины N + 1;
- считается очевидно p[0] = 0; p[i] = p[i - 1] + a[i - 1];

##### Самая простая задача 
- Дан массив a[N] и Q запросов вида (l[i], r[i]). Для каждого запроса найти a[l[i]] + a[l[i] + 1] + ... + a[r[i] - 1]; (запрос на полуинтервале)
- ans[i] = p[r[i]] - p[l[i]];

### Трюк с префиксной разностью
- Путь есть массив a[N], изначально заполненный 0.
- Приходит Q запросов (l[i], r[i], x[i])
	- ко всем a[j] : l[i] <= j < r[i] добавить число x[i].
- после этого нужно вывести то, что получилось в массиве a;

##### Преобразование
- Пусть есть какой-то массив a, сделаем с ним кое-что довольно странное:
	- пусть в массиве d длины N: d[0] = a[0], d[i] = a[i] - a[i - 1];
- как из таког массива обратно получить массив a?
- не трудно заметить, что a[i] = p[i + 1], где p - массив префиксных сумм d;

##### Решение
- Посмотрим, как меняется массив d, если в массиве a сделать прибавление на отрезке.
- d[l] уменьшается на x, d[r] увеличивается на x (стоит нарисовать на примере) - а такое очень легко делать
- будем поддерживать массив d, изменения в котором легко делать, и в самом конце восстановим a, как префиксную сумму d.

##### Обобщение
- пусть для массива a мы хотим выполнять следующую операцию: для чисел l, r, x:
	- a[l] += x;
	- a[l + 1] += 2 * x;
	- a[l + 2] += 3 * x;
	...
	- a[r - 1] += (r - l) * x;
- рассмотрим, каким изменениям это соответствует в массиве d. - прибавление на отрезке и ещё в точке
- тогда для массива dd - последовательные разности последовательных разностей - прибавление в 4х точках. (или оставить изменения в точке и применить их сразу в d, тогда в dd - только в 2х точках).
- теперь восстановим d по dd, и a по d - и того O(n);

### Подотрезок максимальной суммы
- для массива a найти такие l, r, что a[l] + a[l + 1] + .. + a[r - 1] максимально.

##### Решение
- давайте запишем a[l] + a[l + 1] + ... + a[r - 1] через то, что уже знаем = p[r] - p[l];
- то есть чтобы найти отрезок наибольшей суммы с концем в r, нужно найти наименьшее p[l] : (l < r);
- Пойдем слева направо, будем считать префиксные суммы, и параллельно поддерживать минимальную префиксную сумму.

### Подотрезок фиксированной суммы
- пусть дан массив a[N], найти самый короткий отрезок в a, такой что сумма на нём = K
- Для начала попробуем найти хоть 1 такой подотрезок.
- если отрезок [l, r) имеет сумму K, значит p[r] - p[l] = K, сложим все p[i] в сет, а потом ещё ра пройдем по массиву,  для i проверим, есть ли в сете число p[i] - K;
	- вот тольлько в таком решении есть 1 маленькая ошибка: мы можем нечаянно найти индекс > i, что образует некорректный подотрезок
- Решаеься эта проблема очень просто: когда мы решаем, может ли i быть правой границей отрезка в сете должны лежать только префиксные суммы элементов меньше него, это очень легко сделать, просто проходом слева направа и поддержанием сета.

##### Так что там с минимальной длинной?
- Осталось лишь слегка модифицировать алгоритм:
	- когда мы проверяем, может ли i быть правой границей отрезка, мы смотрим, есть ли в set число p[i] - K, теперь если да, то нам бы хотелось знать его индекс, а если их несколько, то знгать наибольший такой индекс
	- давайте вместо set хранить map(значение -> индекс), и если встречаем значение, которое уже есть - просто перезаписываем

##### Упражнение
- решить ту же самую задачу, не используя структуры сложнее, чем vector

### Небольшое отступление
- Пусть дана матрица N\*M, и запросы (xl, xr, yl, yr) - найти сумму на соответствующей подматрице.
- У префиксных сумм есть многомерное обобщение - давайте в клетке хранить сумму элементков от неё к одному из углов 
	- как это насчитать?
	- как теперь из этого найти сумму?


## 2 указателя

### Предыдущая задача
- всё ещё хочется найти самый короткий отрезок с суммой хотя бы K;
- Немного упростим задачу, которую решали только что: пусть все a[i] > 0;
- Теперь для какой-то левой границы l подотрезок l r сначала имеет сумму < K, потом, возможно, K, а потом больше K, то есть можно найти бинпоиском

##### Решение за O(n)
- заметим, что если:
	- r0 - первый индекс, такой что sum(a[0] .. a[r0 - 1] >= K)
	- r1 - первый индекс, такой что sum(a[1] .. a[r1 - 1] >= K)
	- ri - первый индекс, такой что sum(a[1] .. a[ri - 1] >= K)
- то последовательность ri возрастает.
- Тогда найдем r0. Потом начиная с r0 найдем r1 и тд. Зная ri для всех i задачу решить не составляет труда.

### Метод 2х указателей
- обобщение того решения, котрое мы только что рассмортели.
- путь нужно найти массив r[i], где r[i] задаётся как первый индекс, удоблетворяющий некоторому уловию (зависящему от i). При чем мы откуда-то знаем, что r[i] >= r[i - 1].
- тогда задача решается за O(n \* check(i, r));
- важно, что r и i могут быть чем угодно, например индексами в разных массивах
- ну и собственно метод 2х указателей - способ решения такой задачи.

### Коньки
- дано n чисел f - размеры ног школьников
- дано m чисел s - размеры коньков
- коньки можно надеть на ноги школьника, если их резмер не меньше размера ног.
- Какое максимально кол-во школьников можно обуть?

##### Решение
- отсортируем оба массива по возрастанию
- для каждого школьника найдем минимальные коньки, которые на него можно надеть.
- теперь пройдем и как-бы сдвинем полученные числа так, чтобы одни коньки не были на одном школьнике
- Можно было иначе: (по сути сделав эти 2 действия одновременно)
	- сохраним указатель r = 0 - первые не занятые коньки
	- пойдем по школьникам с индексом i.
	- Пока (r != m && s[i] > f[r]) r++;
	- добавим к ответу +1 и r++;

### Задачи поинтереснее
- Найти самый короткий отрезок в массиве, на котором хотя бы K различных чисел
- В массиве из каждого элемента выходит стрелочка (ведёт либо за границы массива, либо в какой-то другой элемент)
	- найти самый короткий отрезок, из которого ведёт котя бы K стрелочек.

## Структуры, связанные со стеком
- Ещё раз напомню, что свой стек вам не нужен, можно пользоваться vector<>;

### Операции на стеке

##### +=
- Хочется структуру, которая умеет добавлять эл-ты в конец, удалять элементы с конца, и делать += ко всем элементам.
- Будем рядом со стеком хранить "поправку" - элемент, который нужно добавить к тому, что лежит в стеке, чтобы получить правильное значение.
	- когда достаем элемент, прибавим к нему "поправку", когда кладем - вычтем (чтобы в итоге получилось что нужно);

##### min
- Нужно добавлять эл-ты в конец, удалять с конца, и уметь говорить минимум среди всех чисел
- Так как мы умеем обращаться только к последнему эл-ту, давайте рядом с этим самым элементом хранить и ответ на задачу в случем, если этот эемент - последний.
	- тогда в стеке лежит 2 числа - добавленное и минимум среди всех ниже него - пересчитывать это при добавлении очень легко это поддерживать - минимум среди всех эл-тов, это просто минимум из тебя и всех элементов кроме тебя (лежит в предыдущем элементе)

##### min=
- Добавлять / удалять из конца и применять min= ко всем элементам.
- просто поддерживать какую-то "прибавку" не получается, так как min= необратимая операция
- воспользуемся предыдущей идей, но немного развернём её: Рядом с элементом будем хранить число, min= с которым нужно сделать для всех чисел ниже в стеке.
	- если просят добавить элемент x в конец, добавим {x, inf};
	- если просят сказать, какой элемент в конце выведем min(p.first, p.second)
	- если просят сделать min= y, сделаем p.second min= y;
	- если просят удалить элемент с конца, достанем его, и применим в стеку min= p.second;

### Очередь на 2х стеках
- нужно реализовать структуру данных, которая за O(1) умеет добавлять эл-т в конец, или убирать с начала.
- Нарисуем такую структуру, а теперь поставим перегородку в каком-то месте.
Чтобы положить что-то в конец - нужно просто боложить в конец правой коробки
- чтобы достать элемент из начала
	- если коробка слева не пуста, то можно просто достать элемент из её конца
	- если коробка слева пуста, можно по одному переложить все элементы из правой коробки в левую, и порядок не нарушится

- Мы получили очередь на 2х стеках!
- если вызвать всего n операций push(), (а значит <= n операций pop()), то итоговое время работы будет O(n);
- когда кладем элемент в правый стек, дадим ему с собой 1 монету, её он потратит на то, чтобы перейти в другой стек.

### Операции с очередью
- если вы хотите поддерживать min на очереди, или делать += ко всем эл-там очереди, или min= ко всем эл-там очереди, или ещё кучу операций, которые можно делать со стеком, то написав очередь на 2х стеках, вы теперь можете делать эти операции и на ней!

##### Очередь с минимумом - минимум на скользящем окне
- пусть дан массив a и число k - нужно найти минимумы н всех отрезках массива a длины k
- положим в очередь с минимумом первые k элементов, получим интересующий нас ответ.
- добавим в очередь k+1ый элемент, и удалим 1ый - и так далее

##### Реализация 
- лучше всего завести структуру min_queue, в ней 2 vector < pair < int, int > > и 3 метода
- код;

##### Другая реализация
- иногда полезно решать одну и ту же задачу 2мя разными способами:
- предыдущий был довольно универсальним, этот же именно для задачи "очередь с минимумом"
- параллельно с очередью (std::queue) сохраним дек (std::deque), который будет хранить:
	- последний эл-т очереди, ближайший слева не больше, ближайший слева не больше от него и тд.
	- когда добавляем эл-т в конец, удалим все в deque > него. (не >=);
	- когда забираем элемент из очереди, проверим, не он ли первый в deque, если да, то заберём его.
	- ответ - первый элемент deque
- Зачем вообще это нужно, если есть более универсальный метод за O(n)?
	- сравните размер кода, и поймите, что приятнее писать.

### Что значит, что первый вариант более универсальный? - более интересные операции на очереди
- Очередь с операцией and;